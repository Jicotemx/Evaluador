<!DOCTYPE html>
<html lang="es">
<head>
  <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>

  <meta charset="UTF-8">
  <title>Evaluador num√©rico üßÆ</title>
  <style>
    /* A√±adir cursor para mejor UX */
    .disabled {
      opacity: 0.5;
      pointer-events: none;
      cursor: not-allowed; /* Nueva regla */
    }
    table, th, td { border: 1px solid black; border-collapse: collapse; padding: 4px; }
  </style>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        packages: {'[+]': ['ams']}
      },
      loader: { load: ['[tex]/ams'] },
      startup: {
        pageReady: () => {
          return MathJax.startup.defaultPageReady().then(() => {
            console.log('MathJax listo');
          });
        }
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>

<div id="loginDiv">
  <h2>Acceso</h2>
  <input type="text" id="loginName" placeholder="Tu nombre" />
  <input type="password" id="loginPassword" placeholder="Contrase√±a" />
  <button onclick="login()">Entrar</button>
  <div id="loginMsg" aria-live="polite"></div> </div>
  <hr>
  <p>¬øEres administrador? <a href="/admin">Acceder al Panel de Administraci√≥n</a></p> </div>


<div id="mainDiv" style="display:none">
  <div id="statusMsg" aria-live="polite" style="font-weight: bold;"></div> <div id="timer" style="font-weight:bold"></div>

  <form id="submitForm">
    <h2>Enviar respuesta</h2>
    <label for="submitName">Nombre:</label>
    <input type="text" id="submitName" readonly /><br/>

    <label for="problemSelect">Problema:</label>
    <select id="problemSelect" required onchange="mostrarEnunciado()">
      {% for pid in problems %}<option value="{{ pid }}">{{ pid }}</option>{% endfor %}
    </select><br/>

    <div id="enunciado" style="margin:1em 0; font-size:18px;"></div>

    <label for="answerInput">Respuesta:</label>
    <input type="text" id="answerInput" required /><br/>
    <button type="submit">Enviar</button>
    <div id="submitMsg" aria-live="polite"></div> </form>

  <h3>Tabla de posiciones</h3>
  <table id="rankingTable">
    <thead>
      <tr>
        <th>Participante</th>
        {% for pid in problems %}<th>{{ pid }}</th>{% endfor %}
        <th>Puntos</th><th>Penalizaci√≥n</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <p><a href="/admin">Ir a Panel de Administraci√≥n</a></p>
</div>

<script>
// Datos de problemas inyectados desde Flask
const problemasData = {
  {% for pid, data in problems.items() %}
    "{{ pid }}": {
      "enunciado": {{ data.enunciado | tojson }},
      "respuesta": {{ data.respuesta | tojson }}
    },
  {% endfor %}
};

let startTime = new Date("{{ start_time_iso }}");
let durationSeconds = {{ duration }}; // 'let' para permitir cambios desde el socket
let concursoStatus = "{{ status }}"; // Estado inicial del concurso

// Variables para controlar la renderizaci√≥n de MathJax y el enunciado
let currentProblemId = null;
let currentEnunciadoHtml = null; // Para evitar re-renderizado innecesario de MathJax

// Inicializar Socket.IO
const socket = io();

// Manejar recarga forzada
socket.on('force_reload', () => {
    console.log("Recarga forzada solicitada por el servidor");
    location.reload();
});

// Manejar actualizaciones de configuraci√≥n desde el servidor
socket.on('config_update', (data) => {
    console.log("Configuraci√≥n actualizada recibida:", data);
    if (data.type === 'start_time') {
        startTime = new Date(data.value);
        updateTimer(); // Actualiza el timer inmediatamente
    } else if (data.type === 'duration') {
        durationSeconds = data.value;
        updateTimer(); // Actualiza el timer inmediatamente
    } else if (data.type === 'problems') {
        // Para cambios de problemas, lo m√°s simple es recargar la p√°gina.
        // Una actualizaci√≥n din√°mica ser√≠a mucho m√°s compleja.
        location.reload();
    }
});

// Manejar actualizaciones del ranking desde el servidor
socket.on('ranking_update', (data) => {
    console.log("Ranking actualizado recibido via socket:", data);
    updateRankingTable(data); // Llama a una funci√≥n dedicada para actualizar la tabla
});


function login() {
  const name = document.getElementById("loginName").value.trim();
  const password = document.getElementById("loginPassword").value.trim();
  const loginMsgElem = document.getElementById("loginMsg"); // Referencia una vez

  if (!name || !password) {
    loginMsgElem.textContent = "Falta nombre o contrase√±a.";
    return;
  }

  fetch("/login", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: `name=${encodeURIComponent(name)}&password=${encodeURIComponent(password)}`
  })
  .then(response => {
    if (!response.ok) { // Manejar errores HTTP
        return response.json().then(err => Promise.reject(err));
    }
    return response.json();
  })
  .then(data => {
    if (data.error) {
      loginMsgElem.textContent = data.error;
    } else {
      loginMsgElem.textContent = "Login exitoso!"; // Mensaje de √©xito
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("mainDiv").style.display = "block";
      document.getElementById("submitName").value = name;
      iniciarConcurso();
    }
  })
  .catch(error => {
    console.error("Error en el login:", error);
    loginMsgElem.textContent = error.message || "Error al intentar iniciar sesi√≥n.";
  });
}

// Funci√≥n modificada para mostrar el enunciado y renderizar MathJax
function mostrarEnunciado() {
    const pid = document.getElementById("problemSelect").value;
    const enunciadoDiv = document.getElementById("enunciado");

    let newEnunciadoContent = "";

    if (window.concursoStatus === "before") {
        newEnunciadoContent = "<em>El concurso a√∫n no ha comenzado.</em>";
    } else if (!problemasData[pid]) {
        newEnunciadoContent = "<em>Problema no encontrado.</em>";
    } else {
        newEnunciadoContent = `
            <div class="enunciado-container">
                <strong>Enunciado:</strong>
                <div id="math-content">${problemasData[pid].enunciado}</div>
            </div>
        `;
    }

    // Solo actualiza el DOM y MathJax si el contenido del enunciado ha cambiado
    // o si el problema seleccionado ha cambiado (esto es importante para el dropdown)
    if (newEnunciadoContent !== currentEnunciadoHtml || pid !== currentProblemId) {
        enunciadoDiv.innerHTML = newEnunciadoContent;
        currentEnunciadoHtml = newEnunciadoContent; // Guarda el contenido actual
        currentProblemId = pid; // Guarda el ID del problema actual

        // Asegurar que MathJax se renderice despu√©s de que el DOM est√© listo
        // y solo si hay contenido MathJax potencial
        const mathContentContainer = document.getElementById("math-content");
        if (mathContentContainer && typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            // Usa typesetClear para limpiar y luego typesetPromise para renderizar el nuevo contenido
            MathJax.typesetClear([mathContentContainer]); // Limpia el contenido anterior de MathJax
            MathJax.typesetPromise([mathContentContainer]).catch(err => {
                console.error("MathJax error:", err);
            });
        } else if (typeof MathJax === 'undefined') {
            console.warn("MathJax no est√° cargado o no tiene typesetPromise.");
        }
    }
}


document.addEventListener("DOMContentLoaded", () => {
  // Si el usuario ya est√° logueado (por ejemplo, al recargar la p√°gina), muestra el mainDiv
  if ("{{ logged_in_user }}" !== "None") { // Chequea la variable de Jinja
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("mainDiv").style.display = "block";
      document.getElementById("submitName").value = "{{ logged_in_user }}";
      iniciarConcurso();
  } else {
      mostrarEnunciado(); // Mostrar enunciado inicial (puede ser "antes del concurso")
  }
});

function iniciarConcurso() {
  updateTimer(); // Primera actualizaci√≥n del temporizador
  loadRanking(); // Primera carga del ranking
  mostrarEnunciado(); // Asegurarse de que el enunciado se muestre al iniciar

  // Intervalo para actualizar el temporizador cada segundo
  setInterval(updateTimer, 1000);
  // Intervalo para cargar el ranking cada 10 segundos
  setInterval(loadRanking, 10000);
}

// Funci√≥n mejorada para actualizar el temporizador
function updateTimer() {
    const now = new Date();
    const startTimeObj = new Date(startTime);
    const endTime = new Date(startTimeObj.getTime() + durationSeconds * 1000);

    const timerElem = document.getElementById("timer");
    const form = document.getElementById("submitForm");
    const answerInput = document.getElementById("answerInput");
    const submitButton = form ? form.querySelector("button[type=submit]") : null;
    const statusMsg = document.getElementById("statusMsg");

    if (!timerElem || !form || !answerInput || !submitButton || !statusMsg) return;

    let newConcursoStatus;
    if (now < startTimeObj) {
        newConcursoStatus = "before";
        const diff = Math.floor((startTimeObj - now) / 1000);
        timerElem.textContent = `Comienza en: ${secondsToHMS(diff)}`;
        statusMsg.textContent = "El concurso comenzar√° pronto.";
        answerInput.disabled = true;
        submitButton.disabled = true;
    } else if (now < endTime) {
        newConcursoStatus = "running";
        const elapsed = Math.floor((now - startTimeObj) / 1000);
        const remaining = durationSeconds - elapsed;
        timerElem.textContent = `‚è±Ô∏è Transcurrido: ${secondsToHMS(elapsed)} | ‚åõ Faltan: ${secondsToHMS(remaining)}`;
        statusMsg.textContent = "Concurso en curso";
        answerInput.disabled = false;
        submitButton.disabled = false;
    } else {
        newConcursoStatus = "after";
        timerElem.textContent = "Concurso finalizado.";
        statusMsg.textContent = "Concurso finalizado.";
        answerInput.disabled = true;
        submitButton.disabled = true;
    }

    // Solo actualiza el estado si ha cambiado
    if (newConcursoStatus !== window.concursoStatus) {
        window.concursoStatus = newConcursoStatus;
        mostrarEnunciado(); // Llama a mostrarEnunciado solo si el estado del concurso cambia
    }
}

function secondsToHMS(s) {
  const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s%60;
  return `${h.toString().padStart(2,"0")}:${m.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;
}

document.getElementById("submitForm").onsubmit = e => {
  e.preventDefault();
  const name = document.getElementById("submitName").value.trim();
  const pid = document.getElementById("problemSelect").value;
  const ans = document.getElementById("answerInput").value.trim();
  const submitMsgElem = document.getElementById("submitMsg");

  // Validaci√≥n b√°sica del lado del cliente para la respuesta
  // Puedes expandir esto si sabes si la respuesta debe ser num√©rica, string, etc.
  if (ans === "") {
      submitMsgElem.textContent = "La respuesta no puede estar vac√≠a.";
      submitMsgElem.className = 'message error'; // A√±adir clase de error
      return;
  }

  fetch("/submit", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: `name=${encodeURIComponent(name)}&problem=${encodeURIComponent(pid)}&answer=${encodeURIComponent(ans)}`
  })
  .then(response => {
    if (!response.ok) { // Manejar errores HTTP
        return response.json().then(err => Promise.reject(err));
    }
    return response.json();
  })
  .then(data => {
    submitMsgElem.textContent = data.message || data.error || "";
    submitMsgElem.className = data.error ? 'message error' : 'message success'; // A√±adir clase de √©xito/error
    // Limpiar el campo de respuesta despu√©s de enviar
    document.getElementById("answerInput").value = '';
    // El ranking se actualizar√° v√≠a socketio.on('ranking_update')
  })
  .catch(error => {
    console.error("Error al enviar respuesta:", error);
    submitMsgElem.textContent = error.message || "Error al enviar la respuesta.";
    submitMsgElem.className = 'message error';
  });
};

function loadRanking() {
  fetch("/ranking")
  .then(response => {
    if (!response.ok) { // Manejar errores HTTP
        return response.json().then(err => Promise.reject(err));
    }
    return response.json();
  })
  .then(data => {
    updateRankingTable(data); // Usar la nueva funci√≥n para actualizar la tabla
  })
  .catch(error => {
    console.error("Error al cargar el ranking:", error);
    // Podr√≠as mostrar un mensaje en el ranking table o en la consola
  });
}

// Nueva funci√≥n para actualizar la tabla de ranking (llamada por fetch y socket)
function updateRankingTable(data) {
    const tbody = document.querySelector("#rankingTable tbody");
    tbody.innerHTML = "";
    data.forEach(part => {
      const row = document.createElement("tr");
      // Mapear los estados de los problemas y unirlos en celdas de tabla
      const problemStatusCells = Object.keys(problemasData).map(pId => {
          const status = part.status[pId] || ""; // Asegurarse de que el status existe
          return `<td>${status}</td>`;
      }).join("");

      row.innerHTML = `<td>${part.name}</td>${problemStatusCells}<td>${part.score}</td><td>${part.penalty}</td>`;
      tbody.appendChild(row);
    });
}
</script>

</body>
</html>
