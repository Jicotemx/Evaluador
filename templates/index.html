<!DOCTYPE html>
<html lang="es">
<head>
  <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Evaluador numÃ©rico ðŸ§®</title>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600;700&family=Poppins:wght=400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    /* Global Styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Open Sans', sans-serif; /* Primary body font */
      background: #f0f2f5; /* Light gray background */
      color: #333;
      min-height: 100vh;
      display: flex; /* Use flexbox for easy centering of content */
      flex-direction: column;
      align-items: center; /* Center content horizontally */
      padding: 20px;
    }

    /* Header */
    header {
      width: 100%;
      max-width: 1200px;
      text-align: center;
      margin-bottom: 40px; /* More space below header */
      padding: 20px 0;
      color: #1a2a6c; /* A deep blue for contrast */
    }

    h1 {
      font-family: 'Poppins', sans-serif;
      font-size: 2.8em; /* Larger title */
      font-weight: 700; /* Bolder */
      margin-bottom: 10px;
      color: #1a2a6c; /* Or a darker version of your theme color */
      letter-spacing: -0.5px; /* Slightly tighter letter spacing */
    }

    /* Main Container for Cards */
    .container {
      width: 100%;
      max-width: 1200px; /* Slightly wider */
      margin: 0 auto;
      display: flex; /* Flexbox for main content layout */
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 30px; /* Space between cards */
      justify-content: center; /* Center cards if they don't fill the width */
    }

    /* Card Styling */
    .card {
      background-color: #ffffff; /* Pure white */
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08); /* Softer, more diffused shadow */
      padding: 30px;
      flex: 1; /* Allow cards to grow and shrink */
      min-width: 300px; /* Minimum width before wrapping */
      position: relative;
      overflow: hidden;
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Smooth transitions */
    }

    .card:hover {
      transform: translateY(-5px); /* Subtle lift on hover */
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.12); /* Slightly stronger shadow on hover */
    }

    /* Optional: Remove or modify the diagonal pattern */
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, rgba(230, 230, 230, 0.1) 25%, transparent 25%, transparent 50%, rgba(230, 230, 230, 0.1) 50%, rgba(230, 230, 230, 0.1) 75%, transparent 75%, transparent);
      background-size: 20px 20px;
      opacity: 0.2; /* Make it more subtle */
      z-index: 0;
    }

    h2 {
      font-family: 'Poppins', sans-serif;
      font-size: 1.8em;
      font-weight: 600;
      color: #333;
      margin-bottom: 25px; /* More spacing below subtitles */
      border-bottom: 2px solid #eee; /* Subtle separator */
      padding-bottom: 10px;
      text-align: center; /* Center card titles */
    }

    /* Form Elements */
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #555;
      font-size: 0.95em;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"],
    select {
      width: 100%;
      padding: 12px 15px;
      margin-bottom: 15px;
      border: 1px solid #ddd;
      border-radius: 8px; /* More rounded corners */
      font-size: 1em;
      color: #555;
      background-color: #fcfcfc;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    input[type="text"]:focus,
    input[type="password"]:focus,
    input[type="number"]:focus,
    select:focus {
      outline: none;
      border-color: #007bff; /* Highlight on focus */
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.15); /* Subtle blue glow */
    }

    button {
      padding: 12px 25px;
      background-color: #007bff; /* Primary blue */
      color: white;
      border: none;
      border-radius: 8px; /* More rounded corners */
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.1s ease;
      font-weight: 600; /* Bolder text */
      box-shadow: 0 4px 10px rgba(0, 123, 255, 0.2); /* Subtle button shadow */
    }

    button:hover {
      background-color: #0056b3; /* Darker blue on hover */
      transform: translateY(-2px); /* Subtle lift */
    }

    button:active {
      transform: translateY(0); /* Press effect */
    }

    .form-group {
      margin-bottom: 20px; /* Space between form elements */
    }

    .button-group {
        display: flex;
        gap: 15px; /* Space between buttons */
        justify-content: center;
        margin-top: 20px;
    }
    .button-group button {
        flex-grow: 1; /* Make buttons grow to fill space */
        max-width: 250px; /* Limit max width of buttons */
    }

    /* Message Styling (Success/Error) */
    .message {
      padding: 12px 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      font-weight: 600;
      text-align: center;
      opacity: 0; /* Start hidden */
      transform: translateY(-10px); /* Start slightly above */
      animation: fadeInSlideDown 0.5s forwards; /* Animation for messages */
    }

    .message.success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .message.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    /* Keyframe animation for messages */
    @keyframes fadeInSlideDown {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Timer Styling */
    #timer {
      font-family: 'Poppins', sans-serif;
      font-size: 3.5em; /* Larger timer */
      font-weight: 700;
      color: #28a745; /* Green for active timer */
      text-align: center;
      margin-bottom: 20px;
      background-color: #e6ffe6; /* Light green background */
      padding: 15px 20px;
      border-radius: 12px;
      border: 1px solid #c3e6cb;
      box-shadow: 0 4px 15px rgba(40, 167, 69, 0.1);
      width: fit-content; /* Adjust width to content */
      margin-left: auto;
      margin-right: auto;
    }

    /* Style for when the timer is finished */
    #timer.finished {
      color: #dc3545; /* Red when finished */
      background-color: #ffe6e6; /* Light red background */
      border-color: #f5c6cb;
      box-shadow: 0 4px 15px rgba(220, 53, 69, 0.1);
    }

    /* Problem Enunciado Styling */
    .enunciado-container {
      padding: 20px; /* Add internal padding */
      background-color: #fefefe;
      border-radius: 8px;
      border: 1px solid #eee; /* Subtle border */
      margin-top: 20px;
    }

    .enunciado-container strong {
      display: block; /* Make "Enunciado:" a block element */
      font-size: 1.1em;
      margin-bottom: 15px; /* More space below the title */
      color: #1a2a6c;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
    }

    #math-content {
        line-height: 1.8; /* Improve readability of math and text */
        font-size: 1.05em;
        color: #444;
    }
    #math-content p {
        margin-bottom: 1em; /* Space between paragraphs in MathJax content */
    }
    #math-content ul, #math-content ol {
        margin-left: 25px;
        margin-bottom: 1em;
    }
    #math-content li {
        margin-bottom: 0.5em;
    }

    /* Ranking Table Styling */
    table {
      width: 100%;
      border-collapse: collapse; /* Remove double borders */
      margin-top: 20px;
      background-color: #ffffff;
      border-radius: 8px; /* Rounded corners for the table */
      overflow: hidden; /* Ensures border-radius applies to content */
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); /* Subtle table shadow */
    }

    th, td {
      padding: 15px 20px; /* More padding */
      text-align: left;
      border-bottom: 1px solid #eee; /* Lighter border */
    }

    th {
      background-color: #e9ecef; /* Light gray header background */
      color: #495057; /* Darker text for headers */
      font-weight: 700; /* Bolder headers */
      text-transform: uppercase; /* Uppercase for headers */
      font-size: 0.9em; /* Slightly smaller font for headers */
    }

    tr:nth-child(even) {
      background-color: #f8f9fa; /* Zebra striping for readability */
    }

    tr:hover {
      background-color: #e2f0ff; /* Subtle highlight on row hover */
      cursor: pointer;
    }

    /* Style for the problem status cells */
    td {
      font-weight: 500;
      color: #333;
    }

    /* Specific styles for problem status (e.g., 'Correcto', 'Incorrecto', 'Pendiente') */
    td.status-correct { color: #28a745; font-weight: 600; }
    td.status-incorrect { color: #dc3545; font-weight: 600; }
    td.status-pending { color: #ffc107; font-weight: 600; }
    td.status-not-attempted { color: #6c757d; font-style: italic; }


    /* Responsive Design */
    @media (max-width: 768px) {
      body {
        padding: 15px;
      }
      .container {
        flex-direction: column; /* Stack cards vertically on small screens */
        gap: 20px;
      }
      .card {
        min-width: unset; /* Remove min-width constraint */
        width: 100%; /* Full width */
      }
      h1 {
        font-size: 2em;
      }
      h2 {
        font-size: 1.5em;
      }
      th, td {
        padding: 10px 15px; /* Reduce padding on smaller screens */
        font-size: 0.9em;
      }
      .button-group {
        flex-direction: column; /* Stack buttons vertically */
      }
      .button-group button {
          width: 100%;
          max-width: unset;
      }
      #timer {
          font-size: 2.5em;
      }
    }

  </style>
</head>
<body>
  <header>
    <h1>Evaluador numÃ©rico ðŸ§®</h1>
  </header>

  <div class="container">
    <div id="submissionSection" class="card">
      <h2>Tiempo restante</h2>
      <div id="timer">Cargando...</div>

      <div id="loginForm" class="form-group">
        <h2>Ingresar / Registrar</h2>
        <label for="teamName">Nombre del equipo:</label>
        <input type="text" id="teamName" placeholder="Ej. Los Matematicos" required>
        <label for="teamPassword">ContraseÃ±a:</label>
        <input type="password" id="teamPassword" placeholder="ContraseÃ±a secreta" required>
        <div class="button-group">
            <button onclick="login()">Ingresar</button>
            <button onclick="register()">Registrar</button>
        </div>
        <div id="loginMessage" class="message" style="display: none;"></div>
      </div>

      <div id="problemSelectionAndSubmission" style="display: none;">
        <h2>Enviar SoluciÃ³n</h2>
        <p>Bienvenido, <strong id="loggedInTeamName"></strong>!</p>
        <div class="form-group">
            <label for="problemSelect">Selecciona un problema:</label>
            <select id="problemSelect"></select>
        </div>
        <div class="form-group">
            <label for="answer">Tu respuesta:</label>
            <input type="text" id="answer" placeholder="Introduce tu respuesta aquÃ­">
        </div>
        <div class="button-group">
            <button onclick="submitAnswer()">Enviar Respuesta</button>
            <button onclick="logout()">Cerrar SesiÃ³n</button>
        </div>
        <div id="submissionMessage" class="message" style="display: none;"></div>
        <div class="enunciado-container" style="margin-top: 25px;">
            <strong>Enunciado:</strong>
            <div id="math-content">Selecciona un problema para ver su enunciado.</div>
        </div>
      </div>
    </div>

    <div id="rankingSection" class="card">
      <h2>Tabla de Posiciones</h2>
      <table id="rankingTable">
        <thead>
          <tr>
            <th>Equipo</th>
            <th>Puntos</th>
            <th>PenalizaciÃ³n</th>
          </tr>
        </thead>
        <tbody>
          </tbody>
      </table>
    </div>
  </div>

  <script>
    // Tu JavaScript existente, con la modificaciÃ³n a updateRankingTable
    const socket = io();
    let problemasData = {};
    let currentProblemId = null; // Para controlar si el enunciado ha cambiado
    let currentEnunciadoHtml = null; // Para evitar re-renderizados innecesarios de MathJax

    // Obtener problemas y ranking iniciales del servidor
    document.addEventListener('DOMContentLoaded', () => {
        // Cargar problemas iniciales
        fetch('/get_problems')
            .then(response => response.json())
            .then(data => {
                problemasData = data;
                populateProblemSelect(problemasData);
                // Si ya hay un problema seleccionado (por ejemplo, al recargar la pÃ¡gina),
                // asegÃºrate de que el enunciado se muestre.
                if (document.getElementById('problemSelect').value) {
                    showProblemEnunciado(document.getElementById('problemSelect').value);
                }
            })
            .catch(error => console.error('Error al cargar problemas:', error));

        // Cargar ranking inicial
        fetch('/get_ranking')
            .then(response => response.json())
            .then(data => {
                updateRankingTable(data.ranking);
                updateProblemHeaders(data.problem_ids); // Actualizar cabeceras de problemas
            })
            .catch(error => console.error('Error al cargar ranking:', error));

        // Cargar estado de la sesiÃ³n y el tiempo
        checkLoginStatus();
        updateTimerDisplay(); // Initial display

        // Configurar intervalo para el temporizador si el tiempo no ha terminado
        if (!timerFinished) { // Check if the timer has already finished on load
            setInterval(updateTimerDisplay, 1000);
        }
    });

    // Manejar actualizaciones del ranking desde el servidor
    socket.on('ranking_update', (data) => {
        console.log("Ranking actualizado recibido via socket:", data);
        updateRankingTable(data); // Llama a una funciÃ³n dedicada para actualizar la tabla
    });

    // Manejar actualizaciones de configuraciÃ³n (como START_TIME o DURATION)
    socket.on('config_update', (data) => {
        console.log("ConfiguraciÃ³n actualizada recibida via socket:", data);
        if (data.type === 'time') {
            // Suponiendo que la hora del servidor se envÃ­a en un formato ISO
            START_TIME_SERVER = new Date(data.startTime);
            DURATION_MINUTES = data.durationMinutes;
            updateTimerDisplay(); // Actualiza inmediatamente el temporizador
        } else if (data.type === 'problems') {
            problemasData = data.value;
            populateProblemSelect(problemasData);
            // Si hay un problema seleccionado actualmente, recarga su enunciado
            if (document.getElementById('problemSelect').value) {
                showProblemEnunciado(document.getElementById('problemSelect').value);
            }
            // TambiÃ©n re-renderiza la tabla de ranking si es necesario para nuevas columnas de problemas
            fetch('/get_ranking')
                .then(response => response.json())
                .then(data => {
                    updateRankingTable(data.ranking);
                    updateProblemHeaders(data.problem_ids);
                })
                .catch(error => console.error('Error al cargar ranking despuÃ©s de problemas:', error));
        }
    });

    // Manejar recarga forzada
    socket.on('force_reload', () => {
        console.log("Recarga forzada solicitada por el servidor");
        location.reload();
    });


    // ===================================
    // Funciones de UI y LÃ³gica del Cliente
    // ===================================

    let timerFinished = false; // Flag to stop interval if timer is done
    let START_TIME_SERVER; // This will be set by the server on initial load or config update
    let DURATION_MINUTES; // This will be set by the server


    async function checkLoginStatus() {
        try {
            const response = await fetch('/check_login_status');
            const data = await response.json();
            if (data.logged_in) {
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('problemSelectionAndSubmission').style.display = 'block';
                document.getElementById('loggedInTeamName').textContent = data.team_name;
            } else {
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('problemSelectionAndSubmission').style.display = 'none';
            }
            // Update time based on server data, important for initial load
            START_TIME_SERVER = new Date(data.start_time);
            DURATION_MINUTES = data.duration_minutes;
            updateTimerDisplay(); // Call immediately to show correct time
        } catch (error) {
            console.error('Error checking login status:', error);
            displayMessage('loginMessage', 'Error al verificar estado de sesiÃ³n.', 'error');
        }
    }


    function updateTimerDisplay() {
        if (!START_TIME_SERVER || !DURATION_MINUTES) {
            document.getElementById('timer').textContent = "Esperando hora de inicio...";
            return;
        }

        const now = new Date();
        const endTime = new Date(START_TIME_SERVER.getTime() + DURATION_MINUTES * 60 * 1000);
        const timeRemaining = endTime - now;

        const timerElement = document.getElementById('timer');

        if (timeRemaining <= 0) {
            timerElement.textContent = "Â¡Tiempo terminado!";
            timerElement.classList.add('finished');
            timerFinished = true; // Set flag to true
            // Optionally, disable submission form here
            document.getElementById('problemSelectionAndSubmission').querySelector('button[onclick="submitAnswer()"]').disabled = true;
            return;
        }

        const totalSeconds = Math.floor(timeRemaining / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        const formatTime = (unit) => String(unit).padStart(2, '0');

        timerElement.textContent = `${formatTime(hours)}:${formatTime(minutes)}:${formatTime(seconds)}`;
        timerElement.classList.remove('finished');
        timerFinished = false; // Ensure flag is false if timer is running
    }


    function displayMessage(elementId, message, type) {
        const messageDiv = document.getElementById(elementId);
        messageDiv.textContent = message;
        messageDiv.className = `message ${type}`;
        messageDiv.style.display = 'block';
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 5000); // Ocultar despuÃ©s de 5 segundos
    }

    async function login() {
        const teamName = document.getElementById('teamName').value;
        const teamPassword = document.getElementById('teamPassword').value;
        try {
            const response = await fetch('/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ team_name: teamName, password: teamPassword })
            });
            const data = await response.json();
            if (data.success) {
                displayMessage('loginMessage', data.message, 'success');
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('problemSelectionAndSubmission').style.display = 'block';
                document.getElementById('loggedInTeamName').textContent = teamName;
                socket.emit('login_update'); // Notificar al servidor que un usuario ha iniciado sesiÃ³n
            } else {
                displayMessage('loginMessage', data.message, 'error');
            }
        } catch (error) {
            console.error('Error during login:', error);
            displayMessage('loginMessage', 'Error al intentar ingresar. IntÃ©ntalo de nuevo.', 'error');
        }
    }

    async function register() {
        const teamName = document.getElementById('teamName').value;
        const teamPassword = document.getElementById('teamPassword').value;
        try {
            const response = await fetch('/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ team_name: teamName, password: teamPassword })
            });
            const data = await response.json();
            if (data.success) {
                displayMessage('loginMessage', data.message, 'success');
            } else {
                displayMessage('loginMessage', data.message, 'error');
            }
        } catch (error) {
            console.error('Error during registration:', error);
            displayMessage('loginMessage', 'Error al intentar registrar. IntÃ©ntalo de nuevo.', 'error');
        }
    }

    async function logout() {
        try {
            const response = await fetch('/logout', {
                method: 'POST'
            });
            const data = await response.json();
            if (data.success) {
                displayMessage('submissionMessage', data.message, 'success');
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('problemSelectionAndSubmission').style.display = 'none';
                document.getElementById('loggedInTeamName').textContent = '';
                socket.emit('logout_update'); // Notificar al servidor que un usuario ha cerrado sesiÃ³n
            } else {
                displayMessage('submissionMessage', data.message, 'error');
            }
        } catch (error) {
            console.error('Error during logout:', error);
            displayMessage('submissionMessage', 'Error al intentar cerrar sesiÃ³n. IntÃ©ntalo de nuevo.', 'error');
        }
    }

    function populateProblemSelect(problems) {
        const select = document.getElementById('problemSelect');
        select.innerHTML = '<option value="">-- Selecciona un problema --</option>'; // OpciÃ³n por defecto
        for (const pid in problems) {
            const option = document.createElement('option');
            option.value = pid;
            option.textContent = `Problema ${pid}`;
            select.appendChild(option);
        }
        select.removeEventListener('change', handleProblemSelectChange); // Remove old listener
        select.addEventListener('change', handleProblemSelectChange); // Add new listener
    }

    function handleProblemSelectChange() {
        const selectedProblemId = document.getElementById('problemSelect').value;
        if (selectedProblemId) {
            showProblemEnunciado(selectedProblemId);
        } else {
            document.getElementById('math-content').innerHTML = "Selecciona un problema para ver su enunciado.";
            currentProblemId = null; // Reset current problem ID
            currentEnunciadoHtml = null; // Reset current enunciado content
        }
    }

    function showProblemEnunciado(pid) {
        const enunciadoDiv = document.getElementById('math-content');
        let newEnunciadoContent = '';
        if (problemasData[pid]) {
            newEnunciadoContent = `
            <div class="enunciado-container">
                <strong>Enunciado:</strong>
                <div id="math-content-inner">${problemasData[pid].enunciado}</div>
            </div>
        `;
        }

        // Only update the DOM and MathJax if the enunciate content has changed
        // or if the selected problem has changed (this is important for the dropdown)
        if (newEnunciadoContent !== currentEnunciadoHtml || pid !== currentProblemId) {
            enunciadoDiv.innerHTML = newEnunciadoContent;
            currentEnunciadoHtml = newEnunciadoContent; // Save current content
            currentProblemId = pid; // Save current problem ID

            // Ensure MathJax renders after the DOM is ready
            // and only if there's potential MathJax content
            const mathContentContainer = document.getElementById("math-content-inner"); // Use inner ID
            if (mathContentContainer && typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                // Use typesetClear to clear and then typesetPromise to render new content
                MathJax.typesetClear([mathContentContainer]); // Clear previous MathJax content
                MathJax.typesetPromise([mathContentContainer]).catch(err => {
                    console.error("MathJax error:", err);
                });
            } else if (typeof MathJax === 'undefined') {
                console.warn("MathJax is not loaded or does not have typesetPromise.");
            }
        }
    }


    async function submitAnswer() {
        if (timerFinished) {
            displayMessage('submissionMessage', 'El tiempo ha terminado. No se pueden enviar mÃ¡s respuestas.', 'error');
            return;
        }

        const problemId = document.getElementById('problemSelect').value;
        const answer = document.getElementById('answer').value;

        if (!problemId) {
            displayMessage('submissionMessage', 'Por favor, selecciona un problema.', 'error');
            return;
        }
        if (!answer) {
            displayMessage('submissionMessage', 'Por favor, introduce tu respuesta.', 'error');
            return;
        }

        try {
            const response = await fetch('/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ problem_id: problemId, answer: answer })
            });
            const data = await response.json();
            if (data.success) {
                displayMessage('submissionMessage', data.message, 'success');
                document.getElementById('answer').value = ''; // Limpiar campo de respuesta
                // No es necesario actualizar el ranking aquÃ­, el servidor lo emitirÃ¡
            } else {
                displayMessage('submissionMessage', data.message, 'error');
            }
        } catch (error) {
            console.error('Error during submission:', error);
            displayMessage('submissionMessage', 'Error al enviar respuesta. IntÃ©ntalo de nuevo.', 'error');
        }
    }

    // Function to update problem headers dynamically
    function updateProblemHeaders(problemIds) {
        const tableHeadRow = document.querySelector("#rankingTable thead tr");
        // Remove existing problem headers (keep Team, Points, Penalty)
        let existingProblemHeaders = tableHeadRow.querySelectorAll('th:not(:first-child):not(:last-child):not(:nth-last-child(2))');
        existingProblemHeaders.forEach(th => th.remove());

        // Insert new problem headers before 'Puntos'
        const pointsHeader = tableHeadRow.querySelector('th:nth-last-child(2)'); // Get the 'Puntos' header
        problemIds.forEach(pId => {
            const th = document.createElement('th');
            th.textContent = `P${pId}`; // E.g., PA, PB, PC
            tableHeadRow.insertBefore(th, pointsHeader);
        });
    }


    // Updated updateRankingTable function with class additions for styling
    function updateRankingTable(data) {
        const tbody = document.querySelector("#rankingTable tbody");
        tbody.innerHTML = ""; // Clear existing rows

        // Ensure problem headers are up-to-date if data contains problem_ids
        if (data.length > 0 && data[0].status) {
            const problem_ids_from_data = Object.keys(data[0].status).sort();
            updateProblemHeaders(problem_ids_from_data);
        }


        data.forEach(part => {
          const row = document.createElement("tr");
          // Map problem statuses to table cells with specific classes
          const problemStatusCells = Object.keys(problemasData).map(pId => { // Use problemasData keys for consistent order
              const status = part.status[pId] || ""; // Get status, default to empty string if not found
              let statusClass = '';
              // Determine class based on status
              switch (status.toLowerCase()) {
                  case 'correcto':
                      statusClass = 'status-correct';
                      break;
                  case 'incorrecto':
                      statusClass = 'status-incorrect';
                      break;
                  case 'pendiente':
                      statusClass = 'status-pending';
                      break;
                  case '': // For problems not attempted or status not yet set
                      statusClass = 'status-not-attempted';
                      break;
                  default:
                      statusClass = ''; // Fallback
              }
              return `<td class="${statusClass}">${status}</td>`; // Add the class to the td
          }).join("");

          row.innerHTML = `<td>${part.name}</td>${problemStatusCells}<td>${part.score}</td><td>${part.penalty}</td>`;
          tbody.appendChild(row);
        });
    }

  </script>

</body>
</html>
