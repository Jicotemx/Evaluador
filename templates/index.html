<!DOCTYPE html>
<html lang="es">
<head>
  <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Evaluador num√©rico üßÆ</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    body {
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: #333;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .card {
      background-color: rgba(255, 255, 255, 0.92);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      padding: 30px;
      margin-bottom: 30px;
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background: linear-gradient(90deg, #4facfe, #00f2fe);
    }
    
    h1, h2, h3 {
      color: #1a2a6c;
      margin-bottom: 20px;
      text-align: center;
    }
    
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #ff8a00, #e52e71);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-top: 10px;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #1a2a6c;
    }
    
    input, select, button {
      width: 100%;
      padding: 14px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      transition: all 0.3s;
    }
    
    input:focus, select:focus {
      border-color: #4facfe;
      outline: none;
      box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.3);
    }
    
    button {
      background: linear-gradient(90deg, #4facfe, #00f2fe);
      color: white;
      font-weight: bold;
      border: none;
      cursor: pointer;
      margin-top: 10px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .disabled {
      opacity: 0.5;
      pointer-events: none;
      cursor: not-allowed;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      background: white;
      border-radius: 8px;
      overflow: hidden;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 12px 15px;
      text-align: center;
    }
    
    th {
      background: linear-gradient(90deg, #4facfe, #00f2fe);
      color: white;
      font-weight: bold;
    }
    
    tr:nth-child(even) {
      background-color: #f8f9fa;
    }
    
    tr:hover {
      background-color: #e9f7fe;
    }
    
    .status-box {
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      margin: 20px 0;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .running {
      background: linear-gradient(90deg, #38ef7d, #11998e);
      color: white;
    }
    
    .before {
      background: linear-gradient(90deg, #ffb347, #ffcc33);
      color: white;
    }
    
    .after {
      background: linear-gradient(90deg, #ff416c, #ff4b2b);
      color: white;
    }
    
    .timer {
      font-size: 1.5rem;
      font-weight: bold;
      text-align: center;
      padding: 15px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.1);
      margin: 20px 0;
      color: #1a2a6c;
    }
    
    .message {
      padding: 15px;
      margin: 15px 0;
      border-radius: 8px;
      text-align: center;
    }
    
    .success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .admin-link {
      text-align: center;
      margin-top: 20px;
    }
    
    .admin-link a {
      color: #1a2a6c;
      font-weight: bold;
      text-decoration: none;
      padding: 10px 20px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 30px;
      transition: all 0.3s;
      display: inline-block;
    }
    
    .admin-link a:hover {
      background: white;
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }
    
    .logo {
      text-align: center;
      font-size: 4rem;
      margin: 20px 0;
      color: white;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .flex-container {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .flex-container > div {
      flex: 1;
    }
    
    @media (max-width: 768px) {
      .flex-container {
        flex-direction: column;
      }
    }
  </style>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        packages: {'[+]': ['ams']}
      },
      loader: { load: ['[tex]/ams'] },
      startup: {
        pageReady: () => {
          return MathJax.startup.defaultPageReady().then(() => {
            console.log('MathJax listo');
          });
        }
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="container">
    <div class="logo">üßÆ</div>
    <h1>Sistema de Evaluaci√≥n Num√©rica</h1>
    
    <div id="loginDiv" class="card">
      <h2>Acceso al Sistema</h2>
      <div class="form-group">
        <label for="loginName">Nombre de usuario:</label>
        <input type="text" id="loginName" placeholder="Ingresa tu nombre">
      </div>
      
      <div class="form-group">
        <label for="loginPassword">Contrase√±a:</label>
        <input type="password" id="loginPassword" placeholder="Ingresa tu contrase√±a">
      </div>
      
      <button onclick="login()">Entrar al sistema</button>
      <div id="loginMsg" class="message" aria-live="polite"></div>
      
      <hr style="margin: 20px 0; border-color: #eee;">
      
      <div class="admin-link">
        <p>¬øEres administrador? <a href="/admin">Acceder al Panel de Administraci√≥n</a></p> 
      </div>
    </div>

    <div id="mainDiv" class="card" style="display:none">
      <button id="logoutButton" class="logout-btn">Salir del sistema</button>
      
      <div class="flex-container">
        <div id="statusMsg" class="status-box running" aria-live="polite" style="font-weight: bold;">Concurso en curso</div>
        <div id="timer" class="timer" style="font-weight:bold">‚è±Ô∏è Transcurrido: 00:00:00 | ‚åõ Faltan: 02:00:00</div>
      </div>

      <form id="submitForm">
        <h2>Enviar respuesta</h2>
        
        <div class="form-group">
          <label for="submitName">Nombre:</label>
          <input type="text" id="submitName" readonly>
        </div>
        
        <div class="form-group">
          <label for="problemSelect">Problema:</label>
          <select id="problemSelect" required onchange="mostrarEnunciado()">
            {% for pid in problems %}<option value="{{ pid }}">{{ pid }}</option>{% endfor %}
          </select>
        </div>

        <div id="enunciado" class="form-group" style="margin:1em 0; padding: 20px; background: #f8f9fa; border-radius: 8px; font-size:18px;">
          <em>El concurso a√∫n no ha comenzado.</em>
        </div>

        <div class="form-group">
          <label for="answerInput">Respuesta:</label>
          <input type="text" id="answerInput" required placeholder="Ingresa tu respuesta" pattern="[-+]?\d*\.?\d+" title="Ingrese un valor num√©rico">
        </div>
        
        <button type="submit">Enviar respuesta</button>
        <div id="submitMsg" class="message" aria-live="polite"></div>
      </form>

      <h3>Tabla de posiciones</h3>
      <table id="rankingTable">
        <thead>
          <tr>
            <th>Participante</th>
            {% for pid in problems %}<th>{{ pid }}</th>{% endfor %}
            <th>Puntos</th>
            <th>Penalizaci√≥n</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

<script>
// Datos de problemas inyectados desde Flask
const problemasData = {
  {% for pid, data in problems.items() %}
    "{{ pid }}": {
      "enunciado": {{ data.enunciado | tojson }},
      "respuesta": {{ data.respuesta | tojson }}
    },
  {% endfor %}
};

let startTime = new Date("{{ start_time_iso }}");
let durationSeconds = {{ duration }}; // 'let' para permitir cambios desde el socket
let concursoStatus = "{{ status }}"; // Estado inicial del concurso

// Variables para controlar la renderizaci√≥n de MathJax y el enunciado
let currentProblemId = null;
let currentEnunciadoHtml = null; // Para evitar re-renderizado innecesario de MathJax

// Inicializar Socket.IO
const socket = io();

// Manejar recarga forzada
socket.on('force_reload', () => {
    console.log("Recarga forzada solicitada por el servidor");
    location.reload();
});

// Manejar actualizaciones de configuraci√≥n desde el servidor
socket.on('config_update', (data) => {
    console.log("Configuraci√≥n actualizada recibida:", data);
    if (data.type === 'start_time') {
        startTime = new Date(data.value);
        updateTimer(); // Actualiza el timer inmediatamente
    } else if (data.type === 'duration') {
        durationSeconds = data.value;
        updateTimer(); // Actualiza el timer inmediatamente
    } else if (data.type === 'problems') {
        // Para cambios de problemas, lo m√°s simple es recargar la p√°gina.
        // Una actualizaci√≥n din√°mica ser√≠a mucho m√°s compleja.
        location.reload();
    }
});

// Manejar actualizaciones del ranking desde el servidor
socket.on('ranking_update', (data) => {
    console.log("Ranking actualizado recibido via socket:", data);
    updateRankingTable(data); // Llama a una funci√≥n dedicada para actualizar la tabla
});


function login() {
  const name = document.getElementById("loginName").value.trim();
  const password = document.getElementById("loginPassword").value.trim();
  const loginMsgElem = document.getElementById("loginMsg");

  if (!name || !password) {
    loginMsgElem.textContent = "Falta nombre o contrase√±a.";
    loginMsgElem.className = 'message error';
    return;
  }

  fetch("/login", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: `name=${encodeURIComponent(name)}&password=${encodeURIComponent(password)}`
  })
  .then(response => {
    if (!response.ok) { // Manejar errores HTTP
        return response.json().then(err => Promise.reject(err));
    }
    return response.json();
  })
  .then(data => {
    if (data.error) {
      loginMsgElem.textContent = data.error;
      loginMsgElem.className = 'message error';
    } else {
      loginMsgElem.textContent = "¬°Login exitoso!";
      loginMsgElem.className = 'message success';
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("mainDiv").style.display = "block";
      document.getElementById("submitName").value = name;
      iniciarConcurso();
    }
  })
  .catch(error => {
    console.error("Error en el login:", error);
    loginMsgElem.textContent = error.message || "Error al intentar iniciar sesi√≥n.";
    loginMsgElem.className = 'message error';
  });
}

// Funci√≥n de logout
function logout() {
  fetch("/logout", {
      method: "POST"
  })
  .then(response => response.json())
  .then(data => {
      if (data.message) {
          document.getElementById("mainDiv").style.display = "none";
          document.getElementById("loginDiv").style.display = "block";
          document.getElementById("loginName").value = "";
          document.getElementById("loginPassword").value = "";
          document.getElementById("loginMsg").textContent = data.message;
          document.getElementById("loginMsg").className = 'message success';
      } else {
          console.error("Error al cerrar sesi√≥n:", data.error);
          document.getElementById("loginMsg").textContent = data.error || "Error al cerrar sesi√≥n.";
          document.getElementById("loginMsg").className = 'message error';
      }
  })
  .catch(error => {
      console.error("Error de conexi√≥n al cerrar sesi√≥n:", error);
      document.getElementById("loginMsg").textContent = "Error de conexi√≥n al cerrar sesi√≥n.";
      document.getElementById("loginMsg").className = 'message error';
  });
}

// Registrar evento de logout cuando el DOM est√© cargado
document.addEventListener("DOMContentLoaded", () => {
  // Registrar logout si el bot√≥n existe
  const logoutButton = document.getElementById("logoutButton");
  if (logoutButton) {
    logoutButton.addEventListener("click", logout);
  }

  // Si el usuario ya est√° logueado (por ejemplo, al recargar la p√°gina), muestra el mainDiv
  if ("{{ logged_in_user }}" !== "None") { // Chequea la variable de Jinja
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("mainDiv").style.display = "block";
      document.getElementById("submitName").value = "{{ logged_in_user }}";
      iniciarConcurso();
  } else {
      mostrarEnunciado(); // Mostrar enunciado inicial (puede ser "antes del concurso")
  }
});

function iniciarConcurso() {
  updateTimer(); // Primera actualizaci√≥n del temporizador
  loadRanking(); // Primera carga del ranking
  mostrarEnunciado(); // Asegurarse de que el enunciado se muestre al iniciar

  // Intervalo para actualizar el temporizador cada segundo
  setInterval(updateTimer, 1000);
  // Intervalo para cargar el ranking cada 10 segundos
  setInterval(loadRanking, 10000);
}

// Funci√≥n mejorada para actualizar el temporizador
function updateTimer() {
    const now = new Date();
    const startTimeObj = new Date(startTime);
    const endTime = new Date(startTimeObj.getTime() + durationSeconds * 1000);

    const timerElem = document.getElementById("timer");
    const form = document.getElementById("submitForm");
    const answerInput = document.getElementById("answerInput");
    const submitButton = form ? form.querySelector("button[type=submit]") : null;
    const statusMsg = document.getElementById("statusMsg");

    if (!timerElem || !form || !answerInput || !submitButton || !statusMsg) return;

    let newConcursoStatus;
    if (now < startTimeObj) {
        newConcursoStatus = "before";
        const diff = Math.floor((startTimeObj - now) / 1000);
        timerElem.textContent = `Comienza en: ${secondsToHMS(diff)}`;
        statusMsg.textContent = "El concurso comenzar√° pronto.";
        statusMsg.className = 'status-box before';
        answerInput.disabled = true;
        submitButton.disabled = true;
    } else if (now < endTime) {
        newConcursoStatus = "running";
        const elapsed = Math.floor((now - startTimeObj) / 1000);
        const remaining = durationSeconds - elapsed;
        timerElem.textContent = `‚è±Ô∏è Transcurrido: ${secondsToHMS(elapsed)} | ‚åõ Faltan: ${secondsToHMS(remaining)}`;
        statusMsg.textContent = "Concurso en curso";
        statusMsg.className = 'status-box running';
        answerInput.disabled = false;
        submitButton.disabled = false;
    } else {
        newConcursoStatus = "after";
        timerElem.textContent = "Concurso finalizado.";
        statusMsg.textContent = "Concurso finalizado.";
        statusMsg.className = 'status-box after';
        answerInput.disabled = true;
        submitButton.disabled = true;
    }

    // Solo actualiza el estado si ha cambiado
    if (newConcursoStatus !== window.concursoStatus) {
        window.concursoStatus = newConcursoStatus;
        mostrarEnunciado(); // Llama a mostrarEnunciado solo si el estado del concurso cambia
    }
}

function secondsToHMS(s) {
  const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s%60;
  return `${h.toString().padStart(2,"0")}:${m.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;
}

document.getElementById("submitForm").onsubmit = e => {
  e.preventDefault();
  const name = document.getElementById("submitName").value.trim();
  const pid = document.getElementById("problemSelect").value;
  const ans = document.getElementById("answerInput").value.trim();
  const submitMsgElem = document.getElementById("submitMsg");

  // Validaci√≥n b√°sica del lado del cliente para la respuesta
  if (ans === "") {
      submitMsgElem.textContent = "La respuesta no puede estar vac√≠a.";
      submitMsgElem.className = 'message error';
      return;
  }

  fetch("/submit", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: `name=${encodeURIComponent(name)}&problem=${encodeURIComponent(pid)}&answer=${encodeURIComponent(ans)}`
  })
  .then(response => {
    if (!response.ok) { // Manejar errores HTTP
        return response.json().then(err => Promise.reject(err));
    }
    return response.json();
  })
  .then(data => {
    submitMsgElem.textContent = data.message || data.error || "";
    submitMsgElem.className = data.error ? 'message error' : 'message success'; // A√±adir clase de √©xito/error
    // Limpiar el campo de respuesta despu√©s de enviar
    document.getElementById("answerInput").value = '';
    // El ranking se actualizar√° v√≠a socketio.on('ranking_update')
  })
  .catch(error => {
    console.error("Error al enviar respuesta:", error);
    submitMsgElem.textContent = error.message || "Error al enviar la respuesta.";
    submitMsgElem.className = 'message error';
  });
};

function loadRanking() {
  fetch("/ranking")
  .then(response => {
    if (!response.ok) { // Manejar errores HTTP
        return response.json().then(err => Promise.reject(err));
    }
    return response.json();
  })
  .then(data => {
    updateRankingTable(data); // Usar la nueva funci√≥n para actualizar la tabla
  })
  .catch(error => {
    console.error("Error al cargar el ranking:", error);
    // Podr√≠as mostrar un mensaje en el ranking table o en la consola
  });
}

// Funci√≥n para actualizar la tabla de ranking
function updateRankingTable(data) {
    const tbody = document.querySelector("#rankingTable tbody");
    tbody.innerHTML = "";
    data.forEach(part => {
      const row = document.createElement("tr");
      // Mapear los estados de los problemas y unirlos en celdas de tabla
      const problemStatusCells = Object.keys(problemasData).map(pId => {
          const status = part.status[pId] || ""; // Asegurarse de que el status existe
          return `<td>${status}</td>`;
      }).join("");

      row.innerHTML = `<td>${part.name}</td>${problemStatusCells}<td>${part.score}</td><td>${part.penalty}</td>`;
      tbody.appendChild(row);
    });
}

// Funci√≥n modificada para mostrar el enunciado y renderizar MathJax
function mostrarEnunciado() {
    const pid = document.getElementById("problemSelect").value;
    const enunciadoDiv = document.getElementById("enunciado");

    let newEnunciadoContent = "";

    if (window.concursoStatus === "before") {
        newEnunciadoContent = "<em>El concurso a√∫n no ha comenzado.</em>";
    } else if (!problemasData[pid]) {
        newEnunciadoContent = "<em>Problema no encontrado.</em>";
    } else {
        newEnunciadoContent = `
            <div class="enunciado-container">
                <strong>Enunciado:</strong>
                <div id="math-content">${problemasData[pid].enunciado}</div>
            </div>
        `;
    }

    // Solo actualiza el DOM y MathJax si el contenido del enunciado ha cambiado
    // o si el problema seleccionado ha cambiado (esto es importante para el dropdown)
    if (newEnunciadoContent !== currentEnunciadoHtml || pid !== currentProblemId) {
        enunciadoDiv.innerHTML = newEnunciadoContent;
        currentEnunciadoHtml = newEnunciadoContent; // Guarda el contenido actual
        currentProblemId = pid; // Guarda el ID del problema actual

        // Asegurar que MathJax se renderice despu√©s de que el DOM est√© listo
        // y solo si hay contenido MathJax potencial
        const mathContentContainer = document.getElementById("math-content");
        if (mathContentContainer && typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            // Usa typesetClear para limpiar y luego typesetPromise para renderizar el nuevo contenido
            MathJax.typesetClear([mathContentContainer]); // Limpia el contenido anterior de MathJax
            MathJax.typesetPromise([mathContentContainer]).catch(err => {
                console.error("MathJax error:", err);
            });
        } else if (typeof MathJax === 'undefined') {
            console.warn("MathJax no est√° cargado o no tiene typesetPromise.");
        }
    }
}
</script>

</body>
</html>
