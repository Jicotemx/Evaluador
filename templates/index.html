<!DOCTYPE html>
<html lang="es">
<head>
  <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>

  <meta charset="UTF-8">
  <title>Evaluador numérico 🧮</title>
  <style>
    .disabled { opacity: 0.5; pointer-events: none; }
    table, th, td { border: 1px solid black; border-collapse: collapse; padding: 4px; }
  </style>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        packages: {'[+]': ['ams']}
      },
      loader: { load: ['[tex]/ams'] },
      startup: {
        pageReady: () => {
          return MathJax.startup.defaultPageReady().then(() => {
            console.log('MathJax listo');
          });
        }
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>

<div id="loginDiv">
  <h2>Acceso Participante</h2> <input type="text" id="loginName" placeholder="Tu nombre" />
  <input type="password" id="loginPassword" placeholder="Contraseña" />
  <button onclick="login()">Entrar</button>
  <p id="loginMessage" style="color: red;"></p>
  <hr>
  <p>¿Eres administrador? <a href="/admin">Acceder al Panel de Administración</a></p> </div>

<div id="mainContent" style="display: none;">
  <h2>¡Bienvenido, <span id="userNameDisplay"></span>!</h2>
  <button id="logoutButton">Salir</button> 

  <p>Tiempo restante: <span id="timeRemaining"></span></p>
  <p>Tiempo transcurrido: <span id="elapsedTime"></span></p> <p id="contestStatus"></p>

  <h3>Problemas</h3>
  <form id="problemDisplayForm"> <label for="problemSelect">Seleccionar Problema:</label>
    <select id="problemSelect"></select><br>
  </form>
  <div id="problemEnunciado">
    </div>

  <h3>Enviar Respuesta</h3>
  <form id="submitForm">
    <label for="answerInput">Tu Respuesta:</label>
    <input type="text" id="answerInput" placeholder="Ej: 3.14159 o tu respuesta exacta" /><br>
    <button type="submit" id="submitButton">Enviar</button>
    <p id="submitMsg"></p>
  </form>

  <h3>Clasificación</h3>
  <table id="rankingTable">
    <thead>
      <tr>
        <th>Participante</th>
        <th>Puntos</th>
        <th>Penalización</th>
      </tr>
    </thead>
    <tbody>
      </tbody>
  </table>
</div>

<script>
  const socket = io();
  let contestStartTime;
  let contestDurationSeconds;
  let currentProblems = {};
  let userName = ''; // Variable para almacenar el nombre del usuario logeado

  // Función de login
  function login() {
      const name = document.getElementById("loginName").value.trim();
      const password = document.getElementById("loginPassword").value.trim();

      fetch("/login", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: `name=${encodeURIComponent(name)}&password=${encodeURIComponent(password)}`
      })
      .then(response => response.json())
      .then(data => {
          if (data.message) {
              document.getElementById("loginMessage").textContent = data.message;
              document.getElementById("loginDiv").style.display = "none";
              document.getElementById("mainContent").style.display = "block";
              userName = name; // Guardar el nombre de usuario
              document.getElementById("userNameDisplay").textContent = userName; // Mostrar en la UI
              // Cargar estado inicial y ranking después del login
              fetchContestConfig(); 
              loadRanking();
          } else {
              document.getElementById("loginMessage").textContent = data.error;
          }
      })
      .catch(error => {
          console.error("Error durante el login:", error);
          document.getElementById("loginMessage").textContent = "Error de conexión al intentar iniciar sesión.";
      });
  }

  // Manejador del botón de Salir
  document.getElementById("logoutButton").addEventListener("click", () => {
      fetch("/logout", {
          method: "POST"
      })
      .then(response => response.json())
      .then(data => {
          if (data.message) {
              // Si el cierre de sesión fue exitoso, ocultar contenido principal y mostrar login
              document.getElementById("mainContent").style.display = "none";
              document.getElementById("loginDiv").style.display = "block";
              document.getElementById("loginName").value = ""; // Limpiar campos de login
              document.getElementById("loginPassword").value = "";
              document.getElementById("loginMessage").textContent = data.message;
              userName = ''; // Limpiar el nombre de usuario almacenado
          } else {
              console.error("Error al cerrar sesión:", data.error);
              document.getElementById("loginMessage").textContent = data.error || "Error al cerrar sesión.";
          }
      })
      .catch(error => {
          console.error("Error de conexión al cerrar sesión:", error);
          document.getElementById("loginMessage").textContent = "Error de conexión al cerrar sesión.";
      });
  });

  // Fetch initial contest configuration
  function fetchContestConfig() {
    fetch('/contest_config')
      .then(response => response.json())
      .then(data => {
        contestStartTime = new Date(data.start_time);
        contestDurationSeconds = data.duration;
        currentProblems = data.problems;
        updateProblemSelect(currentProblems); // Actualiza el select y muestra el primer problema
        updateContestDisplay();
      })
      .catch(error => console.error('Error fetching contest config:', error));
  }

  // NUEVO: Función para mostrar solo un problema seleccionado
  function displayProblem(pid) {
    const problemEnunciadoDiv = document.getElementById("problemEnunciado");
    problemEnunciadoDiv.innerHTML = ""; // Limpiar contenido anterior

    if (pid && currentProblems[pid]) {
        const p = document.createElement("p");
        p.innerHTML = `<strong>Problema ${pid}:</strong> ${currentProblems[pid].enunciado}`;
        problemEnunciadoDiv.appendChild(p);
    } else {
        problemEnunciadoDiv.textContent = "Selecciona un problema para ver su enunciado.";
    }

    // Renderizar MathJax de nuevo si está disponible para el nuevo contenido
    if (typeof MathJax !== 'undefined') {
      MathJax.typesetPromise().then(() => {
        // console.log('MathJax rendering complete for single problem.');
      });
    }
  }

  // Actualiza el select de problemas y establece el evento change
  function updateProblemSelect(problems) {
    const select = document.getElementById("problemSelect");
    select.innerHTML = "";
    
    // Obtener las IDs de los problemas y ordenarlas alfabéticamente
    const sortedPids = Object.keys(problems).sort();

    sortedPids.forEach(pid => {
      const option = document.createElement("option");
      option.value = pid;
      option.textContent = `Problema ${pid}`;
      select.appendChild(option);
    });

    // Añadir el evento listener para cambiar el problema mostrado
    select.addEventListener("change", () => {
        displayProblem(select.value);
    });

    // Mostrar el primer problema por defecto si hay alguno
    if (sortedPids.length > 0) {
        select.value = sortedPids[0]; // Establecer el primer problema como seleccionado
        displayProblem(sortedPids[0]); // Mostrar su enunciado
    } else {
        displayProblem(null); // No hay problemas para mostrar
    }
  }

  function updateContestDisplay() {
      const now = new Date();
      const endTime = new Date(contestStartTime.getTime() + contestDurationSeconds * 1000);
      const timeRemainingSpan = document.getElementById("timeRemaining");
      const elapsedTimeSpan = document.getElementById("elapsedTime"); // NUEVO: Elemento tiempo transcurrido
      const contestStatusDiv = document.getElementById("contestStatus");
      const submitButton = document.getElementById("submitButton");

      let elapsedSeconds = 0; // Inicializar tiempo transcurrido

      if (now < contestStartTime) {
          const timeLeft = Math.floor((contestStartTime.getTime() - now.getTime()) / 1000);
          timeRemainingSpan.textContent = secondsToHMS(timeLeft);
          elapsedTimeSpan.textContent = "00:00:00"; // Antes de iniciar, 0 transcurrido
          contestStatusDiv.textContent = "El concurso aún no ha comenzado.";
          submitButton.disabled = true;
          submitButton.classList.add("disabled");
      } else if (now >= contestStartTime && now <= endTime) {
          const timeLeft = Math.floor((endTime.getTime() - now.getTime()) / 1000);
          elapsedSeconds = Math.floor((now.getTime() - contestStartTime.getTime()) / 1000); // Calcular tiempo transcurrido
          timeRemainingSpan.textContent = secondsToHMS(timeLeft);
          elapsedTimeSpan.textContent = secondsToHMS(elapsedSeconds); // Mostrar tiempo transcurrido
          contestStatusDiv.textContent = "¡Concurso en curso!";
          submitButton.disabled = false;
          submitButton.classList.remove("disabled");
      } else { // now > endTime
          timeRemainingSpan.textContent = "00:00:00";
          elapsedSeconds = Math.floor((endTime.getTime() - contestStartTime.getTime()) / 1000); // Tiempo total transcurrido
          elapsedTimeSpan.textContent = secondsToHMS(elapsedSeconds); // Mostrar tiempo total
          contestStatusDiv.textContent = "El concurso ha terminado.";
          submitButton.disabled = true;
          submitButton.classList.add("disabled");
      }
  }

  // Actualizar cada segundo
  setInterval(updateContestDisplay, 1000);

  function secondsToHMS(s) {
    const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s%60;
    return `${h.toString().padStart(2,"0")}:${m.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;}

  document.getElementById("submitForm").onsubmit = e => {
    e.preventDefault();
    // Se usa la variable global userName y el problema seleccionado del dropdown
    const pid = document.getElementById("problemSelect").value;
    const ans = document.getElementById("answerInput").value.trim();
    fetch("/submit", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: `name=${encodeURIComponent(userName)}&problem=${encodeURIComponent(pid)}&answer=${encodeURIComponent(ans)}`
    }).then(r => r.json()).then(data => {
      document.getElementById("submitMsg").textContent = data.message || data.error || "";
      loadRanking();
    });
  };

  function loadRanking() {
    fetch("/ranking").then(r => r.json()).then(data => {
      const tbody = document.querySelector("#rankingTable tbody");
      const theadRow = document.querySelector("#rankingTable thead tr");
      
      // Limpiar encabezado de problemas anterior (excepto las primeras y últimas columnas)
      let currentProblemHeaders = theadRow.querySelectorAll('.problem-header');
      currentProblemHeaders.forEach(header => header.remove());

      // Obtener las IDs de los problemas y ordenarlas alfabéticamente para la tabla
      const sortedPids = Object.keys(currentProblems).sort();

      // Añadir encabezados de problemas dinámicamente en orden alfabético
      sortedPids.forEach(pid => {
        const th = document.createElement("th");
        th.classList.add("problem-header"); // Para poder seleccionarlos y eliminarlos
        th.textContent = pid;
        theadRow.insertBefore(th, theadRow.children[1]); // Insertar después de "Participante"
      });

      tbody.innerHTML = "";
      data.forEach(part => {
        const row = document.createElement("tr");
        let statusCells = '';
        // Llenar las celdas de estado de los problemas en el mismo orden alfabético
        sortedPids.forEach(pid => {
            const status = part.status[pid] || ''; // Obtener el estado del problema, si no existe es vacío
            statusCells += `<td>${status}</td>`;
        });
        row.innerHTML = `<td>${part.name}</td>${statusCells}<td>${part.score}</td><td>${part.penalty}</td>`;
        tbody.appendChild(row);
      });
    });
  }

  // Websocket updates
  socket.on('config_update', function(data) {
    console.log('Config update received:', data);
    if (data.type === 'start_time') {
      contestStartTime = new Date(data.value);
    } else if (data.type === 'duration') {
      contestDurationSeconds = data.value;
    } else if (data.type === 'problems') {
      currentProblems = data.value;
      updateProblemSelect(currentProblems); // Actualiza y muestra el primer problema
    }
    updateContestDisplay();
  });

  socket.on('ranking_update', function(data) {
    console.log('Ranking update received.');
    loadRanking();
  });

  socket.on('force_reload', function() {
    console.log('Force reload received. Reloading page...');
    window.location.reload();
  });

  // Check if user is already logged in (e.g., after a page refresh)
  fetch('/check_session')
      .then(response => response.json())
      .then(data => {
          if (data.logged_in) {
              userName = data.user_name;
              document.getElementById("userNameDisplay").textContent = userName;
              document.getElementById("loginDiv").style.display = "none";
              document.getElementById("mainContent").style.display = "block";
              fetchContestConfig();
              loadRanking();
          } else {
              document.getElementById("loginDiv").style.display = "block";
              document.getElementById("mainContent").style.display = "none";
          }
      })
      .catch(error => {
          console.error("Error checking session:", error);
          // Fallback to showing login if session check fails
          document.getElementById("loginDiv").style.display = "block";
          document.getElementById("mainContent").style.display = "none";
      });

</script>
</body>
</html>
